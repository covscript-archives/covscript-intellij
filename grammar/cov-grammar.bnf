{
  parserClass='org.covscript.lang.CovParser'
  extends='com.intellij.extapi.psi.ASTWrapperPsiElement'
  psiClassPrefix='Cov'
  psiImplClassSuffix='Impl'
  psiPackage='org.covscript.lang.psi'
  psiImplPackage='org.covscript.lang.psi.impl'

  tokenTypeClass='org.covscript.lang.CovTokenType'
  elementTypeHolderClass='org.covscript.lang.psi.CovTypes'
  elementTypeClass='org.covscript.lang.CovTokenType'
  psiImplUtilClass='org.covscript.lang.psi.impl.CovPsiImplUtils'
}

file ::=
 fileHeader*
 statement*

number ::= NUM
symbol ::= SYM
break ::= BREAK_KEYWORD
continue ::= CONTINUE_KEYWORD
true ::= TRUE_KEYWORD
false ::= FALSE_KEYWORD
null ::= NULL_KEYWORD
comment ::= LINE_COMMENT+
string ::= STR
charLiteral ::= CHAR
endOfLine ::= (EOF comment?)+

fileHeader ::=
   importDeclaration
 | usingDeclaration
 | packageDeclaration
 | endOfLine
 | comment

importDeclaration ::= IMPORT_KEYWORD symbol
usingDeclaration ::= USING_KEYWORD symbol
packageDeclaration ::= PACKAGE_KEYWORD symbol

variableDeclaration ::= (CONST_KEYWORD)? VAR_KEYWORD symbol EQ expression

functionDeclaration ::=
 FUNCTION_KEYWORD symbol LEFT_BRACKET (symbol (COMMA symbol)*)? RIGHT_BRACKET endOfLine
  bodyOfSomething
 END_KEYWORD

namespaceDeclaration ::=
 NAMESPACE_KEYWORD symbol endOfLine
  bodyOfSomething
 END_KEYWORD

structDeclaration ::=
 STRUCT_KEYWORD symbol endOfLine
  ((variableDeclaration | functionDeclaration) endOfLine)*
 END_KEYWORD

bodyOfSomething ::= (statement endOfLine)*

returnStatement ::= RETURN_KEYWORD expression?
throwStatement ::= THROW_KEYWORD expression
tryCatchStatement ::=
 TRY_KEYWORD
  bodyOfSomething
 CATCH_KEYWORD symbol
  bodyOfSomething
 END_KEYWORD

ifStatement ::=
 IF_KEYWORD expression endOfLine
  bodyOfSomething
  (
   ELSE_KEYWORD endOfLine
    bodyOfSomething
  )?
 END_KEYWORD

switchStatement ::=
 SWITCH_KEYWORD expression endOfLine
  (
   CASE_KEYWORD expression endOfLine
    bodyOfSomething
   END_KEYWORD
  )*
  (
   DEFAULT_KEYWORD endOfLine
    bodyOfSomething
   END_KEYWORD
  )?
 END_KEYWORD

whileStatement ::=
 WHILE_KEYWORD expression endOfLine
  bodyOfSomething
 END_KEYWORD

loopUntilStatement ::=
 LOOP_KEYWORD endOfLine
  bodyOfSomething
 (UNTIL_KEYWORD expression endOfLine)?
 END_KEYWORD

forStatement ::=
 FOR_KEYWORD symbol (forTo | forIterate) endOfLine
  bodyOfSomething
 END_KEYWORD

forTo ::= EQ expression TO_KEYWORD expression (STEP_KEYWORD expression)?
forIterate ::= ITERATE_KEYWORD expression

blockStatement ::=
 BLOCK_KEYWORD endOfLine
  bodyOfSomething
 END_KEYWORD

statement ::=
   endOfLine
 | throwStatement
 | returnStatement
 | variableDeclaration
 | functionDeclaration
 | structDeclaration
 | ifStatement
 | whileStatement
 | switchStatement
 | blockStatement
 | forStatement
 | loopUntilStatement
 | tryCatchStatement
 | comment
 | namespaceDeclaration
 | break
 | continue
 | expression

boolean ::= true | false
newExpression ::= (NEW_KEYWORD | GCNEW_KEYWORD) dotChain
arrayLiteral ::= LEFT_B_BRACKET (expression (COMMA expression)*)? RIGHT_B_BRACKET

expression ::=
 prefixOperator?
 primaryExpression
 (
  binaryOperator
  expression
 )?

prefixOperator ::=
   INC_OP
 | DEC_OP
 | MINUS_OP
 | PLUS_OP
 | NOT_OP
 | NOT_KEYWORD
 | TYPEID_KEYWORD

binaryOperator ::=
   EQ
 | DIV_ASS
 | PLUS_ASS
 | MINUS_ASS
 | TIMES_ASS
 | POW_ASS
 | REM_ASS
 | QUESTION_OP
 | PLUS_OP
 | MINUS_OP
 | TIMES_OP
 | DIV_OP
 | REM_OP
 | POW_OP
 | COLON_OP
 | AND_OP
 | AND_KEYWORD
 | OR_OP
 | OR_KEYWORD
 | LT_OP
 | GT_OP
 | EQ_OP
 | LE_OP
 | GE_OP
 | UN_OP

primaryExpression ::=
   newExpression
 | symbolSuffixed
 | number
 | boolean
 | null
 | string
 | charLiteral
 | arrayLiteral
 | LEFT_BRACKET expression RIGHT_BRACKET

symbolSuffixed ::=
 symbol
 (
    (LEFT_S_BRACKET expression RIGHT_S_BRACKET)
  | (LEFT_BRACKET (expression (COMMA expression)*)? RIGHT_BRACKET)
  | (DOT symbolSuffixed)
  | INC_OP
  | DEC_OP
 )?

dotChain ::= symbol (DOT symbol)*

