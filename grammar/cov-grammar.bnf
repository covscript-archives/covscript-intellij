{
  parserClass='org.covscript.lang.CovParser'
  extends='com.intellij.extapi.psi.ASTWrapperPsiElement'
  psiClassPrefix='Cov'
  psiImplClassSuffix='Impl'
  psiPackage='org.covscript.lang.psi'
  psiImplPackage='org.covscript.lang.psi.impl'

  tokenTypeClass='org.covscript.lang.CovTokenType'
  elementTypeHolderClass='org.covscript.lang.psi.CovTypes'
  elementTypeClass='org.covscript.lang.CovElementType'
  psiImplUtilClass='org.covscript.lang.psi.impl.CovPsiImplUtils'
}

file ::=
 fileHeader*
 statement*

private endOfLine ::= EOL+
number ::= NUM
break ::= BREAK_KEYWORD
continue ::= CONTINUE_KEYWORD
true ::= TRUE_KEYWORD
false ::= FALSE_KEYWORD
null ::= NULL_KEYWORD
comment ::= LINE_COMMENT {
	mixin='org.covscript.lang.psi.impl.CovCommentMixin'
	implements=['com.intellij.psi.PsiLanguageInjectionHost' 'com.intellij.psi.PsiComment']
}

string ::= STR
charLiteral ::= CHAR
symbol ::= SYM {
	mixin='org.covscript.lang.psi.impl.CovSymbolMixin'
	implements=['org.covscript.lang.psi.impl.ICovSymbol']
}

parameter ::= SYM {
	mixin='org.covscript.lang.psi.impl.CovParameterMixin'
}

fileHeader ::=
   usingDeclaration
 | importDeclaration
 | packageDeclaration
 | comment
 | endOfLine

importDeclaration ::= IMPORT_KEYWORD symbol
usingDeclaration ::= USING_KEYWORD symbol
packageDeclaration ::= PACKAGE_KEYWORD symbol

variableDeclaration ::= (CONST_KEYWORD)? VAR_KEYWORD symbol EQ expression {
	mixin='org.covscript.lang.psi.impl.CovVariableDeclarationMixin'
}

functionDeclaration ::=
 FUNCTION_KEYWORD symbol LEFT_BRACKET (symbol (COMMA symbol)*)? RIGHT_BRACKET endOfLine
  bodyOfSomething
 END_KEYWORD {
	mixin='org.covscript.lang.psi.impl.CovFunctionDeclarationMixin'
}

namespaceDeclaration ::=
 NAMESPACE_KEYWORD symbol endOfLine
  bodyOfSomething
 END_KEYWORD {
	mixin='org.covscript.lang.psi.impl.CovNamespaceDeclarationMixin'
}

structDeclaration ::=
 STRUCT_KEYWORD symbol endOfLine
  ((variableDeclaration | functionDeclaration) endOfLine)*
 END_KEYWORD

bodyOfSomething ::= (statement endOfLine)* {
	mixin='org.covscript.lang.psi.impl.CovBodyOfSomethingMixin'
}

returnStatement ::= RETURN_KEYWORD expression?

throwStatement ::= THROW_KEYWORD expression

tryCatchStatement ::=
 TRY_KEYWORD endOfLine
  bodyOfSomething
 CATCH_KEYWORD symbol endOfLine
  bodyOfSomething
 END_KEYWORD {
	mixin='org.covscript.lang.psi.impl.CovTryCatchDeclarationMixin'
}

ifStatement ::=
 IF_KEYWORD expression endOfLine
  bodyOfSomething
  (
   ELSE_KEYWORD endOfLine
    bodyOfSomething
  )?
 END_KEYWORD

switchStatement ::=
 SWITCH_KEYWORD expression endOfLine
  (
   (CASE_KEYWORD expression | DEFAULT_KEYWORD) endOfLine
    bodyOfSomething
   END_KEYWORD endOfLine
  )*
 END_KEYWORD

whileStatement ::=
 WHILE_KEYWORD expression endOfLine
  bodyOfSomething
 END_KEYWORD

loopUntilStatement ::=
 LOOP_KEYWORD endOfLine
  bodyOfSomething
 (UNTIL_KEYWORD expression endOfLine)?
 END_KEYWORD

forStatement ::=
 FOR_KEYWORD symbol (forTo | forIterate) endOfLine
  bodyOfSomething
 END_KEYWORD {
	mixin='org.covscript.lang.psi.impl.CovForStatementMixin'
}

forTo ::= EQ expression TO_KEYWORD expression (STEP_KEYWORD expression)?
forIterate ::= ITERATE_KEYWORD expression

blockStatement ::=
 BLOCK_KEYWORD endOfLine
  bodyOfSomething
 END_KEYWORD

statement ::=
   primaryStatement
 | collapsedStatement {
  mixin='org.covscript.lang.psi.impl.CovStatementMixin'
  implements=['org.covscript.lang.psi.impl.ICovStatement']
}

collapsedStatement ::= COLLAPSER_BEGIN primaryStatement? COLLAPSER_END

private primaryStatement ::=
   endOfLine
 | importDeclaration
 | throwStatement
 | returnStatement
 | variableDeclaration
 | functionDeclaration
 | structDeclaration
 | ifStatement
 | whileStatement
 | switchStatement
 | blockStatement
 | forStatement
 | loopUntilStatement
 | tryCatchStatement
 | comment
 | namespaceDeclaration
 | break
 | continue
 | expression

private boolean ::= true | false
newExpression ::= (NEW_KEYWORD | GCNEW_KEYWORD) symbol (DOT symbol)*
arrayLiteral ::= LEFT_B_BRACKET (expression (COMMA expression)*)? RIGHT_B_BRACKET
functionLiteral ::= LEFT_S_BRACKET RIGHT_S_BRACKET LEFT_BRACKET (parameter (COMMA parameter)*)? RIGHT_BRACKET ARROW expression

expression ::=
 suffixedExpression
 (
  binaryOperator
  expression
 )? {
	mixin='org.covscript.lang.psi.impl.CovExpressionMixin'
	implements=['org.covscript.lang.psi.impl.ICovExpression']
}

prefixOperator ::=
   INC_OP
 | DEC_OP
 | MINUS_OP
 | PLUS_OP
 | NOT_OP
 | NOT_KEYWORD
 | TYPEID_KEYWORD
 | TIMES_OP

binaryOperator ::=
   EQ
 | DIV_ASS
 | PLUS_ASS
 | MINUS_ASS
 | TIMES_ASS
 | POW_ASS
 | REM_ASS
 | QUESTION_OP
 | PLUS_OP
 | MINUS_OP
 | TIMES_OP
 | DIV_OP
 | REM_OP
 | POW_OP
 | COLON_OP
 | AND_OP
 | AND_KEYWORD
 | OR_OP
 | OR_KEYWORD
 | LT_OP
 | GT_OP
 | EQ_OP
 | LE_OP
 | GE_OP
 | UN_OP

private primaryExpression ::=
   newExpression
 | symbol
 | number
 | boolean
 | null
 | string
 | charLiteral
 | arrayLiteral
 | functionLiteral
 | bracketExpression

bracketExpression ::= LEFT_BRACKET expression RIGHT_BRACKET

suffixedExpression ::=
 prefixOperator?
 primaryExpression
 (
    (LEFT_S_BRACKET expression RIGHT_S_BRACKET)
  | (LEFT_BRACKET (expression (COMMA expression)*)? RIGHT_BRACKET)
  | ((DOT | ARROW) suffixedExpression)
  | INC_OP
  | DEC_OP
 )*

